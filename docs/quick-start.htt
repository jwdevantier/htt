% local C = require "//common.htt"
% local T = require "tags"
% local code = T.code

% local qex = "//examples/quick-start/components.htt"

% @component importNoteContent
<p>Notice the call to {{code "require"}}. HTT templates are transparently
compiled to Lua as they are first imported.
~></p>
<p>{{T.todo "link to reference on importing"}}</p>
% @end

% @component directiveNote
<p>
HTT interprets lines where text after {{code "%"}} starts with {{code "@"}} differently. These lines are taken to be <em>directives</em>, of which there are currently 2: {{code "@component"}} and {{code "code"}}. We will cover this more below.
~></p>
% @end

% @component variablesFromCtxNote
<p>See the the "Context" section under "Components" for information on how to pass arguments to a component and how to access them.
~></p>
% @end

% @component indentationNote
<p>If you look at the example, you can see that the two calls to {{code "child"}} produces differently indented output.
~></p>

<p>This is because the final indentation of any given line is the sum of:
~></p>
<ul class="mt-2 list-disc list-inside">
    <li>The indentation of the line itself within the component</li>
    <li>The indentation of the line that called its component</li>
    <li>The indentation of the line that called the parent component</li>
    <li>... and so on, all the way up the chain of component calls</li>
</ul>

<p class="mt-4">This sounds complex, but feels natural. Play around and you will see how indentation generally behaves as you would expect and want.
~></p>
% @end


% @component main

{{T.h2 "Hello World"}}
<p>
~>HTT takes a single lua script as its argument, from here you can generate as many files as you want by calling the {{code "render"}} function.
~></p>
<p>Let's create a script, {{code "test-htt.lua"}}:
~></p>

{{@ C.include {file = "examples/quick-start/test-htt.lua"} }}



{{@ C.note {c = importNoteContent} }}

Let's then fill out the template file, {{code "helloworld.htt"}}:

{{@ C.compSrc {file = qex, component = "helloWorld", include_directives = true} }}

If you now run the command {{code "htt test-htt.lua"}}, then the {{code "result.txt"}} file will look like this:

{{@ C.eval {file = qex, component = "helloWorld"}}}

{{T.h4 "To Summarize"}}
<ol class="list-decimal list-inside">
  <li>We wrote a template file, {{code "helloworld.htt"}}, and defined a component, {{code "helloWorld"}}, inside it</li>
  <li>We wrote a lua script, {{code "test-htt.lua"}}, which uses the {{code "render"}} call to render a component, {{code "helloWorld"}}, to a file: {{code "result.txt"}}.</li>
</ol>

{{T.h2 "Using lua inside templates"}}
<p>HTT uses plain Lua for all logic inside of templates. Any line which starts with {{code "%"}} is taken to be a line of Lua code injected verbatim into the compiled template.
~><p>

{{@ C.note {title = "What about '% @component'?", c = directiveNote} }}

{{T.h3 "Looping with Lua"}}
<p>We can use Lua for loops to repeat a block of output like so:
~></p>

{{@ C.compSrc {file = qex, component = "loop3"} }}
{{@ C.eval {file = qex, component = "loop3"}}}

{{T.h3 "Conditional rendering with Lua"}}
<p>We can use Lua if-statements to decide whether to render a block of output or not:
~></p>

{{@ C.compSrc {file = qex, component = "ifRender"}}}

If we render this component, we get:
{{@ C.eval {file = qex, component = "ifRender"} }}

{{T.h3 "Using variables in output"}}
<p>You can use {{T.code (T.raw "{{ ... }}")}} to embed the values of variables or other expressions in the output:
~></p>
{{@ C.compSrc {file = qex, component = "varExample"} }}
{{@ C.eval {file = qex, component = "varExample"}}}

{{@ C.note {title = "What about '% @component'?", c = variablesFromCtxNote} }}

{{T.h2 "Components"}}
<p>Components are the unit of abstraction. Complex outputs should be built by composing smaller components into larger ones.
~></p>

{{T.h3 "Calling components from within components"}}
<p> To call a component, we use this syntax: {{code (T.raw "{{@ component ctx }}")}}. {{code "component"}} is any component and {{code "ctx"}} is the <em>context</em> we want to pass on to the component. The context should be a Lua table and it is the way to pass arguments to the component (including other components, if you want!).
~></p>

<br/>
<p>Given this component:
~></p>
{{@ C.compSrc {file = qex, component = "child", include_directives = true} }}

<p>Let's call it from another component.
~></p>

{{@ C.compSrc {file = qex, component = "parent", include_directives = true} }}

<p>The output becomes:
~></p>
{{@ C.eval {file = qex, component = "parent"}}}

{{@ C.note {title = "How indentation works", c = indentationNote} }}
% @end
