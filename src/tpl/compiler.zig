const std = @import("std");
const tok = @import("token.zig");
const lex = @import("lexer.zig");

const Allocator = std.mem.Allocator;
const Token = tok.Token;
const Lexer = lex.Lexer;
const LexErr = lex.LexErr;

inline fn memwrite(buf: []u8, off: usize, str: []const u8) usize {
    @memcpy(buf[off .. off + str.len], str);
    return off + str.len;
}

inline fn memset_at(buf: []u8, off: usize, num: usize, b: u8) usize {
    @memset(buf[off .. off + num], b);
    return off + num;
}

fn startsWithAnyOf(input: []const u8, comptime slices: []const []const u8) bool {
    inline for (slices) |slice| {
        if (std.mem.startsWith(u8, input, slice)) {
            return true;
        }
    }
    return false;
}

inline fn flush_on_threshold(buf: []u8, cur: usize, threshold: usize, fh: std.fs.File) !usize {
    // if buffer is filling up, flush it out.
    if ((buf.len - cur) < threshold) {
        var wcur: usize = 0;
        while (wcur < cur) {
            wcur += try fh.write(buf[wcur..cur]);
        }
        return cur - wcur;
    }
    return cur;
}

fn write_code_impl(tpl_fpath: []const u8, buf: []u8, cur: usize, out: std.fs.File) !usize {
    var _cur: usize = cur;

    _cur = memwrite(buf, cur, tpl_fpath);
    _cur = memwrite(buf, _cur, ".lua");

    const fh = std.fs.cwd().openFile(buf[cur.._cur], .{ .mode = .read_only }) catch |err| {
        switch (err) {
            error.FileNotFound => return cur,
            else => return err,
        }
    };
    defer fh.close();
    _cur = cur; // no need for the filename any longer

    var rdr = fh.reader();
    while (true) {
        const bytes_read = try rdr.read(buf[_cur..]);
        if (bytes_read == 0) break;
        _cur += bytes_read;

        _cur = try flush_on_threshold(buf, _cur, 1024, out);
    }
    if (_cur != cur) {
        buf[_cur] = '\n';
        _cur += 1;
    }
    return _cur;
}

pub const CompileErrorType = enum {
    lex_err,
    illegal_toplevel_content,
    directive_start_unmatched,
    directive_end_unmatched,
    directive_unknown,
    nested_component_error,
};

pub const CompileErrorData = union(CompileErrorType) {
    lex_err: struct { reason: []const u8, state: []const u8 },
    illegal_toplevel_content: struct { content_type: []const u8 },
    directive_start_unmatched: void,
    directive_end_unmatched: void,
    directive_unknown: struct { tag: []const u8 },
    nested_component_error: void,
};

pub const CompileError = struct {
    reason: []const u8,
    lineno: u32,
    column: u32,
    type: CompileErrorData,
};

pub fn compile(a: Allocator, tpl_fpath: []const u8, out_fpath: []const u8) !?CompileError {
    const tpl_file = try std.fs.cwd().openFile(tpl_fpath, .{ .mode = .read_only });
    defer tpl_file.close();

    const tpl_size = try tpl_file.getEndPos();
    const tpl_contents = try a.alloc(u8, tpl_size);
    defer a.free(tpl_contents);

    _ = try tpl_file.readAll(tpl_contents);

    const tmp_out_fpath = try a.alloc(u8, out_fpath.len + ".tmp".len);
    defer a.free(tmp_out_fpath);

    @memcpy(tmp_out_fpath[0..out_fpath.len], out_fpath);
    @memcpy(tmp_out_fpath[out_fpath.len..], ".tmp");

    const out = try std.fs.cwd().createFile(tmp_out_fpath, .{
        .truncate = true,
        .lock = .exclusive,
    });
    errdefer out.close();

    var lexer = Lexer.init(tpl_fpath, tpl_contents);

    // TODO: maybe scan and determine the longest line first
    const cap = 2048;
    var buf = try a.alloc(u8, cap);
    var dstack = std.ArrayList(Token).init(a);
    defer dstack.deinit();
    defer a.free(buf);
    var cur: usize = 0;
    var code_indent: u32 = 0;
    var in_component = false;

    cur = memwrite(buf, cur, "-- Autogenerated from '");
    cur = memwrite(buf, cur, tpl_fpath);
    cur = memwrite(buf, cur, "'\n");

    cur = try write_code_impl(tpl_fpath, buf, cur, out);

    // define M *after* such that included code cannot overwrite or add elements
    cur = memwrite(buf, cur, "local M = {}\n\n");

    var peek = lexer.nextToken();
    while (true) {
        const t = peek;
        peek = lexer.nextToken();
        switch (t.data) {
            .fresh_line => |fl| {
                if (!in_component) {
                    // This happens @ top-level, we ignore it
                    continue;
                }
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, "_T.fl('");
                cur = memwrite(buf, cur, fl.indent);
                cur = memwrite(buf, cur, "')\n");
            },
            .line_continuation => {
                if (!in_component) {
                    return CompileError{
                        .reason = "content must be inside a component",
                        .lineno = t.lineno,
                        .column = t.col,
                        .type = .{ .illegal_toplevel_content = .{ .content_type = "line continuation sequence" } },
                    };
                }
                // code indentation
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, "_T.cont()\n");
            },
            .text => |txt| {
                if (!in_component) {
                    if (txt.len == 0) {
                        // this happens @ top-level, we ignore it
                        continue;
                    }

                    return CompileError{
                        .reason = "content must be inside a component",
                        .lineno = t.lineno,
                        .column = t.col,
                        .type = .{ .illegal_toplevel_content = .{ .content_type = "text" } },
                    };
                }
                if (!in_component and txt.len != 0) {
                    continue;
                }
                // code indentation
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, "_T.write('");

                // escaping characters where needed
                for (txt) |ch| {
                    if (ch != '\'') {
                        buf[cur] = ch;
                        cur += 1;
                    } else {
                        buf[cur] = '\\';
                        buf[cur + 1] = '\'';
                        cur += 2;
                    }
                }
                cur = memwrite(buf, cur, "')\n");
            },
            .luaexpr => |expr| {
                if (!in_component) {
                    return CompileError{
                        .reason = "content must be inside a component",
                        .lineno = t.lineno,
                        .column = t.col,
                        .type = .{ .illegal_toplevel_content = .{ .content_type = "lua expression" } },
                    };
                }
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, "_T.write(tostring(");
                cur = memwrite(buf, cur, std.mem.trim(u8, expr, " \t")); // TODO: still needed? fix at lexing?
                cur = memwrite(buf, cur, "))\n");
            },
            .render => |rargs| {
                if (!in_component) {
                    return CompileError{
                        .reason = "content must be inside a component",
                        .lineno = t.lineno,
                        .column = t.col,
                        .type = .{ .illegal_toplevel_content = .{ .content_type = "component render call" } },
                    };
                }
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, "_T.render(");
                cur = memwrite(buf, cur, rargs.component);
                cur = memwrite(buf, cur, ", ");
                cur = memwrite(buf, cur, rargs.luaexpr);
                cur = memwrite(buf, cur, ")\n");
            },
            .lualine => |ll| {
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, ll.indent);
                cur = memwrite(buf, cur, ll.lua);
                cur = memwrite(buf, cur, "\n");
            },
            .luablock_line => |lbl| {
                cur = memset_at(buf, cur, code_indent, ' ');
                cur = memwrite(buf, cur, lbl.indent);
                cur = memwrite(buf, cur, lbl.lua);
                cur = memwrite(buf, cur, "\n");
            },
            .directive => {
                const d = t.data.directive;
                if (!std.mem.eql(u8, "end", d.tag)) {
                    try dstack.append(t);
                } else {
                    // END tag
                    if (dstack.popOrNull()) |dtok| {
                        if (std.mem.eql(u8, "component", dtok.data.directive.tag)) {
                            if (code_indent > 1) {
                                code_indent -= 2;
                            }
                            cur = memset_at(buf, cur, code_indent, ' ');
                            cur = memwrite(buf, cur, "end\n\n");

                            // alias components, this is what allows a render call to use
                            // the unqualified (local) name of a component
                            const cname = dtok.data.directive.args;
                            cur = memset_at(buf, cur, code_indent, ' ');
                            cur = memwrite(buf, cur, "local ");
                            cur = memwrite(buf, cur, cname);
                            cur = memwrite(buf, cur, " = M.");
                            cur = memwrite(buf, cur, cname);
                            cur = memwrite(buf, cur, "\n\n");

                            in_component = false;
                        }
                    } else {
                        return CompileError{
                            .reason = "encountered `end`, but no directive tag is open",
                            .lineno = t.lineno,
                            .column = t.col,
                            .type = .{ .directive_start_unmatched = {} },
                        };
                    }
                    continue;
                }

                if (std.mem.eql(u8, "component", d.tag)) {
                    if (in_component) {
                        // TODO: 100% illegal
                        std.debug.print("ERROR, cannot nest components!\n", .{});
                    }
                    cur = memwrite(buf, cur, "function M.");
                    cur = memwrite(buf, cur, d.args);
                    cur = memwrite(buf, cur, "(_T, ctx)\n");
                    code_indent += 2;
                    in_component = true;
                } else if (std.mem.eql(u8, "code", d.tag)) {} else {
                    return CompileError{
                        .reason = "unknown directive type",
                        .lineno = t.lineno,
                        .column = t.col,
                        .type = .{ .directive_unknown = .{ .tag = d.tag } },
                    };
                }
            },
            .eof => {
                if (dstack.popOrNull()) |dtok| {
                    return CompileError{
                        .reason = "directive not closed",
                        .lineno = dtok.lineno,
                        .column = dtok.col,
                        .type = .{ .directive_end_unmatched = {} },
                    };
                }
                break;
            },
            .illegal => |err| {
                // TODO: remove printline
                std.debug.print("Lexing error:\n\tState: {s}\n\tReason: {s}\n\tFile: {s}\n\tLine: {}\n\tColumn: {}\n", .{ @tagName(err.state), err.reason, t.fpath, t.lineno, t.col });
                return CompileError{
                    .reason = "encountered error when lexing source file",
                    .lineno = t.lineno, //
                    .column = t.col,
                    .type = .{ .lex_err = .{ .state = @tagName(err.state), .reason = err.reason } },
                };
            },
            else => {},
        }
        if ((cap - cur) < 1024) {
            _ = try out.write(buf[0..cur]);
            cur = 0;
        }
    }

    cur = memwrite(buf, cur, "\n--export component functions\nreturn M\n");
    _ = try out.write(buf[0..cur]);
    cur = 0;
    // IF good, commit, write
    out.close();
    try std.fs.cwd().rename(tmp_out_fpath, out_fpath);
    return null;
}
